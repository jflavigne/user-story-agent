--- a/src/agent/patch-orchestrator.ts
+++ b/src/agent/patch-orchestrator.ts
@@ -77,7 +77,7 @@ export class PatchValidator {
         if (patch.match?.id && typeof entry === 'object' && 'id' in entry) return (entry as { id?: string }).id === patch.match!.id;
         if (patch.match?.textEquals) {
-          const text = typeof entry === 'object' && 'text' in entry ? (entry as { text: string }).text : ('element' in entry && typeof entry === 'object' ? `${(entry as UIMappingItem).element} | ${(entry as UIMappingItem).behavior}` : '');
+          const text = typeof entry === 'object' && 'text' in entry ? (entry as { text: string }).text : ('productTerm' in entry && typeof entry === 'object' ? `${(entry as UIMappingItem).productTerm} | ${(entry as UIMappingItem).componentName}` : '');
           return text === patch.match!.textEquals;
         }
         return false;
@@ -108,8 +108,8 @@ export class PatchValidator {
     if (path.startsWith('implementationNotes.')) {
       const key = path.replace('implementationNotes.', '') as keyof ImplementationNotes;
-      const value = story.implementationNotes?.[key];
-      return Array.isArray(value) ? value : undefined;
+      const value = story.implementationNotes[key];
+      return value;
     }
     return undefined;
   }
@@ -231,9 +231,9 @@ export class PatchOrchestrator {
     if (patch.path === 'uiMapping') {
       if (!next.uiMapping) next.uiMapping = [];
       const itemToUi = (item: Item): UIMappingItem => {
         const parts = item.text.split(/\s*\|\s*/);
         return {
-          id: item.id,
-          element: parts[0]?.trim() ?? item.text,
-          behavior: parts[1]?.trim() ?? '',
+          id: item.id,
+          productTerm: parts[0]?.trim() ?? item.text,
+          componentName: parts[1]?.trim() ?? '',
         };
       };
       return this.applyArrayPatch(next, 'uiMapping', patch, itemToUi) ?? next;
@@ -242,13 +242,10 @@ export class PatchOrchestrator {
     if (patch.path.startsWith('implementationNotes.')) {
       const key = patch.path.replace('implementationNotes.', '') as keyof ImplementationNotes;
       const arr = next.implementationNotes[key];
-      if (!Array.isArray(arr)) {
-        (next.implementationNotes as Record<string, Item[] | undefined>)[key] = [];
-      }
-      const target = (next.implementationNotes[key] ?? []) as Item[];
-      const applied = this.applyToItemArray(target, patch, (i) => i);
+      const applied = this.applyToItemArray(arr, patch, (i) => i);
       if (applied === null) return null;
-      (next.implementationNotes as Record<string, Item[]>)[key] = applied;
+      next.implementationNotes[key] = applied as Item[];
       return next;
     }
 
@@ -281,7 +278,7 @@ export class PatchOrchestrator {
   ): (Item | UIMappingItem)[] | null {
     const matcher = (entry: Item | UIMappingItem): boolean => {
       if (patch.match?.id && 'id' in entry && entry.id === patch.match.id) return true;
-      const text = 'text' in entry ? entry.text : ('element' in entry ? `${(entry as UIMappingItem).element} | ${(entry as UIMappingItem).behavior}` : '');
+      const text = 'text' in entry ? entry.text : ('productTerm' in entry ? `${(entry as UIMappingItem).productTerm} | ${(entry as UIMappingItem).componentName}` : '');
       if (patch.match?.textEquals && text === patch.match.textEquals) return true;
       return false;
     };
